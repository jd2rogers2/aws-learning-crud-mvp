### udemy course

## CICD
- summary:
    - CodeCommit = version control
    - CodePipeline = pipeline orchestration
    - CodeBuild = build and test
    - CodeDeploy = deploying to EC2
    - CodeStar = scaffolds all the other developer services
    - CodeArtifact = store, publish, share pkgs
    - CodeGuru = ML automated code reviews
    - Cloud9 - online IDE
- CodeCommit
    - secure - ssh or https for auth
    - encrypted using kms
    - no size limit
    - fully managed
    - open source tool integrations
- CodePipeline
    - integrates with all the other tools here
    - configure in stages (like gitlab yml)
        - stages have multiple action groups
    - each pipeline creates artifact(s) in s3
    - fails and cancels can be sent to CloudWatch
    - trigger via CloudWatch events or with periodic codepipeline checks
    - manual approval an option for triggering a stage
        - i.e. triggering CodeDeploy to prod
        - approver must have GetPipeline and PutApprovalResult IAM perms
    - can integrate with CloudFormation
- CodeBuild
    - sources = CodeCommit, S3, bitbucket, github
    - buildspec.yml for instructions
        - must be in root
        - copies in specified source code files
        - runs specific instructions in phases
            - install, pre_build, build, post_build
        - sounds similar to Dockerfile
        - runs in CodeBuild container
        - define env vars here
            - or pull from Secrets Manager or Parameter Store
    - output logs to CloudWatch or S3
    - envs for most languages and docker for the rest
    - can cache files in S3 bucket across builds or for large builds
    - can run locally for troubleshooting beyond logs
    - can run from inside your vpc
- CodeDeploy
    - to EC2, on-prem, Lambda, ECS
    - on fail:
        - auto rollback
        - or trigger CloudWatch alarm
    - appspec.yml defines config
    - rollbacks are really redeploys of last working instance
    - each hosting service has its own lifecycle events, but generally:
        - ApplicationStop, DownloadBundle, BeforeInstall, Install, AfterInstall, ApplicationStart, ValidateService
    - deployment strategies
        - in-place
            - AllAtOnce - down time, fast
            - HalfAtATime - middle of the boat
            - OneAtATime - high availability, slow
        - blue/green
            - new version built on side then replaces
    - CodeDeploy Agent
        - computer user
        - needs to be installed on EC2 instance(s)
        - separately, instance needs S3 permissions to go and get to-be-deployed artifacts
    - Lambda integration
        - linear = % pointing towards new version increases every N minutes
            - i.e. LambdaLinear10PercentEvery3Minutes
        - Canary = point small % to new version then straight to 100%
            - i.e. LambdaCanary10Percent5Minutes
        - AllAtOnce = 100% right away
    - ECS integration
        - only blue/green strategy
        - works similar to Lambda
            - linear, canary, AllAtOnce
            - i.e. ECSCanary10Percent5Minutes
- CodeStar
    - scaffolds all of the other service for you
    - select configured options and it creates a CodeCommit repo with files, creates a CodePipeline with build and deploy to Beanstalk/EC2/etc.
- CodeArtifact
    - dependency storage
    - use with npm, pip, maven, etc.
    - caches dependencies so they're not lost
    - secure
    - proxy to public npmjs stores
    - CodeBuild can get from here instead of public stores
    - can trigger EventBridge events which in turn can trigger CodeDeploy 
        - i.e. on every new dependency version
    - has multiple repositories
    - use "Domain" for shared deps across repositories
- CodeGuru
    - CodeGuru Reviewer = ML code reviews, bugs, security vulnerabilities
        - STATIC code analysis
    - Profiler = code performance analysis
        - on live/runtime of app
    - define how deep in callstack to go
    - define report intervals
- Cloud9
    - online IDE
    - prepackaged with dev envs (js, pythong, etc.)
    - spins up EC2 insts to run code

## Cognito
- federated identities, amzn, FB, google, apple, saml
    - need 3rd party client ID, secret
- user pools
    - customer signin
    - integrates with API gateway and ALB
    - serverless node hits user db
    - MFA (email, phone)
    - PW reset
    - responds with JWT
        - username
        - "sub" property is user id
    - uses SES - simple email service
    - provides UI
        - custom domain - need ACM cert, define in app integration 
    - user mgmt dashboard
    - Lambda triggers on action (i.e. signup)
    - "adaptive auth"
        - generates a risk score based on login (IP, location, device)
        - can do more MFA if high risk
- identity pools ("federated identities")
    - temporary creds
    - for users trying to access aws resources
        - define given IAM policies in cognito
        - policy can give permissions like `cognito-id.sub` for any of this user's dynamodb/s3 data
    - id pool (source/db) can be:
        - 3rd party (fb, google, etc.), cognito user pool, saml
        - guest access (unauthed)

## Lambda
- integrates with Events for cron
- integrates with kinesis for processing streaming data
- can be sync or async
- sync if client needs response
- functions take in event, context args
- networking
    - by default deployed outside your vpc
    - but can put it in your vpc
        - public VPC will not give your Lambda public access in either direction. can't do it
        - Lambda needs specific permissions
        - if private vpc use NAT gateway to make Lambda public
- performance
    - add more RAM to get more vCPUs
    - 3s default timeout, up to 15m
    - can cache connections (i.e. db) across calls if defined outside of function
    - cache (ephemeral) files in /tmp folder for across calls (10GB of space)
    - Lambda Layers for storing dependencies locally rather than reinstalling every run
- concurrency
    - account wide 1000 running instances
    - can set "reserved concurrency" per function
    - can use "provisioned concurrency" to keep X instances warm to reduce initialization after downtime
- logging
    - auto sends to CloudWatch logs
    - can config to send to X-Ray
- Edge Function
    - running lambdas in CloudFront at an edge location
    - CloudFront Functions vs Lambda@Edge
        - 1 only JS - faster
        - 2 only Node or Python
        - 1 ultra small
            - small max mem
            - small max execution time
        - 1 no network, FS, request body access
        - 2 yes
- ALB integration
    - to expose Lambda to https endpoint
    - function must be registered in target group
    - converts http request to json for Lambda
    - Lambda should return json
    - need to configure to handle multi-header values (query param lists)
- async
    - lots of integrations for invoking
        - S3, SNS, CloudWatch Events/EventBridge, and others but not needed
    - events put in a queue
    - retries 3 times if error
    - idempotent is requirement
    - define DLQ for failures
        - Lambda func needs IAM permissions to write to queue
    - 202 response for successful invoke but unknown response (could be failure)
    - permissions live on Lambda function
- event invokation
    - EventBridge cron rule
        - every x time
        - or "cron statement" more granular/specific
    - EventBridge CodePipeline event rule
    - S3 event integration
- event source mapping
    - from kinesis streams, dynamodb streams, sqs queue
    - Lambda polls stream/queue
    - can config Lambda to batch process in parallel
        - usually for high traffic streams
    - error in stream/batch will cause entire batch to reprocess or pause
    - SQS + FIFO
- "destinations"
    - like DLQ but for failed AND successful events
    - for async
        - goes to SQS, SNS, Lambda, or EventBridge bus
    - for event mapping
        - goes to SQS, SNS
- CloudFormation deployment - write yaml, ref S3 zip file with func + deps packaged up
- containerize via ECR, up to 10GB, write standard Dockerfile
    - aws has lambda base images, already cached
- aliases
    - point to a specific version
    - canary deployment (95% pointing to v2 (prod), 5% to v3 (test))


queues vs streams
- both can have lots of messages, need sharding
    - we still partition on a key
- queues are single thread
- queues only send message to 1 consumer
- queues retire message after being sent
- streams have many threads/topics/log file
- streams send messages to all consumers of the topic
- streams persist messages long term as subscribers can get messages from any point in time

### practice tests
## 1 (19 july)
- things to research:
    - review cloud practitioner notes
    ✅ tooling (CodeDeploy, Build)
    ✅ CodeDeploy, appspec listeners/lifecycle hooks
    ✅ cognito
        - IAM - user pools, identity pools
    - dynamodb - streams, parallel scans, throughput, session feature, operations
    - below all one udemy section
        - CloudWatch, detailed monitoring, CloudWatch Events, alarms
        - X-Ray
        - EventBridge
    - Lambda - sqs event source, CloudWatch event source, dep pkg (zip files)
    - ecs - launch types (ec2, fargate), vocab task vs pod etc., HOST_PORT:CONTAINER_PORT mappings (0 for host will be automatically handled), task definitions
    - s3 hive compatible
    - beanstalk - source bundle
    - AWS CLI put-metric-data
    - api gateway caching (maybe compile all caching), mapping templates (xml > json)
    - sqs - config (long polling), system arch, 
    - certificate manager = for issuing SSL/TLS certificates
        - vs kms, secrets mngr, priv cert auth
    - rds proxy = LB sorta for RDS
    - step functions
- SAML = secure assertion markup language
    - xml auth
- DDL = data def language (subset of SQL, create table etc.)


### feecodecamp youtube (eh)

## elastic beanstalk
- "not for production use" per aws
- built on top of cloud formation
- uses EC2, ELB, ASG, CloudWatch under the hood:
- web env
    - single inst or load balanced service
    - asg, elb
        - asg still used for fail handling
- worker env
    - asg, sqs
- deployment methods
    - all at once
        - ship same code to all instances at the same time
        - takes all old instances out of service during
        - fast but dangerous (if new v is broken)
        - downtime (no availability)
    - rolling
        - only on load balanced (needs ELB)
        - in batches
        - slower but fixes probs of all at once
        - rolling back is complicated (needs another rolling deploy)
        - reduced capacity
    - rolling with addtl batch
        - only on load balanced (needs ELB)
        - completely new full batch then delete old
        - rollbacks still difficult
    - immutable
        - completely new asg
        - wait to destroy old asg
            - easy rollbacks
    - blue/green
        - all considered "in-place" except this one
        - similar to immutable but uses new DNS record
        - DNS mappings need to populate to entire internet :(
        - happens at route 53 level
    - configs in .ebextensions folder
        - files have .config
    - env.yml in root to configure defaults
    - EB has its own CLI
    - can use custom AMIs
    - RDS can be added inside or outside env
        - inside is destroyed on instance destroy (deploy)
    
        
