### udemy course

## CICD
- summary:
    - CodeCommit = version control
    - CodePipeline = pipeline orchestration
    - CodeBuild = build and test
    - CodeDeploy = deploying to EC2
    - CodeStar = scaffolds all the other developer services
    - CodeArtifact = store, publish, share pkgs
    - CodeGuru = ML automated code reviews
    - Cloud9 - online IDE
- CodeCommit
    - secure - ssh or https for auth
    - encrypted using kms
    - no size limit
    - fully managed
    - open source tool integrations
- CodePipeline
    - integrates with all the other tools here
    - configure in stages (like gitlab yml)
        - stages have multiple action groups
    - each pipeline creates artifact(s) in s3
    - fails and cancels can be sent to CloudWatch
    - trigger via CloudWatch events or with periodic codepipeline checks
    - manual approval an option for triggering a stage
        - i.e. triggering CodeDeploy to prod
        - approver must have GetPipeline and PutApprovalResult IAM perms
    - can integrate with CloudFormation
- CodeBuild
    - sources = CodeCommit, S3, bitbucket, github
    - buildspec.yml for instructions
        - must be in root
        - copies in specified source code files
        - runs specific instructions in phases
            - install, pre_build, build, post_build
        - sounds similar to Dockerfile
        - runs in CodeBuild container
        - define env vars here
            - or pull from Secrets Manager or Parameter Store
    - output logs to CloudWatch or S3
    - envs for most languages and docker for the rest
    - can cache files in S3 bucket across builds or for large builds
    - can run locally for troubleshooting beyond logs
    - can run from inside your vpc
- CodeDeploy
    - to EC2, on-prem, Lambda, ECS
    - on fail:
        - auto rollback
        - or trigger CloudWatch alarm
    - appspec.yml defines config
    - rollbacks are really redeploys of last working instance
    - each hosting service has its own lifecycle events, but generally:
        - ApplicationStop, DownloadBundle, BeforeInstall, Install, AfterInstall, ApplicationStart, ValidateService
    - deployment strategies
        - in-place
            - AllAtOnce - down time, fast
            - HalfAtATime - middle of the boat
            - OneAtATime - high availability, slow
        - blue/green
            - new version built on side then replaces
    - CodeDeploy Agent
        - computer user
        - needs to be installed on EC2 instance(s)
        - separately, instance needs S3 permissions to go and get to-be-deployed artifacts
    - Lambda integration
        - linear = % pointing towards new version increases every N minutes
            - i.e. LambdaLinear10PercentEvery3Minutes
        - Canary = point small % to new version then straight to 100%
            - i.e. LambdaCanary10Percent5Minutes
        - AllAtOnce = 100% right away
    - ECS integration
        - only blue/green strategy
        - works similar to Lambda
            - linear, canary, AllAtOnce
            - i.e. ECSCanary10Percent5Minutes
- CodeStar
    - scaffolds all of the other service for you
    - select configured options and it creates a CodeCommit repo with files, creates a CodePipeline with build and deploy to Beanstalk/EC2/etc.
- CodeArtifact
    - dependency storage
    - use with npm, pip, maven, etc.
    - caches dependencies so they're not lost
    - secure
    - proxy to public npmjs stores
    - CodeBuild can get from here instead of public stores
    - can trigger EventBridge events which in turn can trigger CodeDeploy 
        - i.e. on every new dependency version
    - has multiple repositories
    - use "Domain" for shared deps across repositories
- CodeGuru
    - CodeGuru Reviewer = ML code reviews, bugs, security vulnerabilities
        - STATIC code analysis
    - Profiler = code performance analysis
        - on live/runtime of app
    - define how deep in callstack to go
    - define report intervals
- Cloud9
    - online IDE
    - prepackaged with dev envs (js, pythong, etc.)
    - spins up EC2 insts to run code

## Cognito
- federated identities, amzn, FB, google, apple, saml
    - need 3rd party client ID, secret
- user pools
    - customer signin
    - integrates with API gateway and ALB
    - serverless node hits user db
    - MFA (email, phone)
    - PW reset
    - responds with JWT
        - username
        - "sub" property is user id
    - uses SES - simple email service
    - provides UI
        - custom domain - need ACM cert, define in app integration 
    - user mgmt dashboard
    - Lambda triggers on action (i.e. signup)
    - "adaptive auth"
        - generates a risk score based on login (IP, location, device)
        - can do more MFA if high risk
- identity pools ("federated identities")
    - temporary creds
    - for users trying to access aws resources
        - define given IAM policies in cognito
        - policy can give permissions like `cognito-id.sub` for any of this user's dynamodb/s3 data
    - id pool (source/db) can be:
        - 3rd party (fb, google, etc.), cognito user pool, saml
        - guest access (unauthed)

## Lambda
- integrates with Events for cron
- integrates with kinesis for processing streaming data
- can be sync or async
- sync if client needs response
- functions take in event, context args
- networking
    - by default deployed outside your vpc
    - but can put it in your vpc
        - public VPC will not give your Lambda public access in either direction. can't do it
        - Lambda needs specific permissions
        - if private vpc use NAT gateway to make Lambda public
- performance
    - add more RAM to get more vCPUs
    - 3s default timeout, up to 15m
    - can cache connections (i.e. db) across calls if defined outside of function
    - cache (ephemeral) files in /tmp folder for across calls (10GB of space)
    - Lambda Layers for storing dependencies locally rather than reinstalling every run
- concurrency
    - account wide 1000 running instances
    - can set "reserved concurrency" per function
        - will always have these instances available, no other function can take them
    - can use "provisioned concurrency" to keep X instances warm to reduce initialization after downtime
        - already initialized exec envs
- logging
    - auto sends to CloudWatch logs
    - can config to send to X-Ray
- Edge Function
    - running lambdas in CloudFront at an edge location
    - CloudFront Functions vs Lambda@Edge
        - 1 only JS - faster
        - 2 only Node or Python
        - 1 ultra small
            - small max mem
            - small max execution time
        - 1 no network, FS, request body access
        - 2 yes
- ALB integration
    - to expose Lambda to https endpoint
    - function must be registered in target group
    - converts http request to json for Lambda
    - Lambda should return json
    - need to configure to handle multi-header values (query param lists)
- async
    - lots of integrations for invoking
        - S3, SNS, CloudWatch Events/EventBridge, and others but not needed
    - events put in a queue
    - retries 3 times if error
    - idempotent is requirement
    - define DLQ for failures
        - Lambda func needs IAM permissions to write to queue
    - 202 response for successful invoke but unknown response (could be failure)
    - permissions live on Lambda function
- event invokation
    - EventBridge cron rule
        - every x time
        - or "cron statement" more granular/specific
    - EventBridge CodePipeline event rule
    - S3 event integration
- event source mapping
    - from kinesis streams, dynamodb streams, sqs queue
    - Lambda polls stream/queue
    - can config Lambda to batch process in parallel
        - usually for high traffic streams
    - error in stream/batch will cause entire batch to reprocess or pause
    - SQS + FIFO
- "destinations"
    - like DLQ but for failed AND successful events
    - for async
        - goes to SQS, SNS, Lambda, or EventBridge bus
    - for event mapping
        - goes to SQS, SNS
- CloudFormation deployment - write yaml, ref S3 zip file with func + deps packaged up
- containerize via ECR, up to 10GB, write standard Dockerfile
    - aws has lambda base images, already cached
- aliases
    - point to a specific version
    - canary deployment (95% pointing to v2 (prod), 5% to v3 (test))
- w/ CodeDeploy
    - uses SAM (serverless application model - serverless IaC that uses CloudFormation)
    - same deployment strategies: linear, canary, all-at-once
- accessing via URL
    - can expose w/out api gateway or ALB
    - CORS config available
    - can only point to 1 alias
    - need to add IAM permissions to lambda with AuthType: None, action: invoke, principal: *
        - cross account then both sides need perms
- integrates with CodeGuru
- limits
    - 10GB of RAM/mem
    - 900s/15m timeout
    - /tmp space of 10G
    - 1000 concurrent instances
    - zip file, 50MB compressed, 250MB uncompressed
    - 4KB of env var space

### Route 53
- DNS, domain registrar
- "zone file" = hashmap url: IP
- "name server" resolves dns queries
- "authoratative" = we configure url -> IP records
- "hostname" ugly aws url aws.region.az.service.instancename.com
- record:
    - domain - url
    - record type - A|AAAA|CNAME|NS
        - A = domain: IPv4
        - AAAA = domain: IPv6
        - CNAME = domain A: domain B
            - CNAME vs alias (A, AAAA)
                - cname = domain to any hostname, must have > 2 domain levels (blah.domain.com)
                - alias = domain to any hostname, can point direct to 2 level domain (domain.com)
                    - free
                    - native health check
        - NS = name servers - reroutes to help in finding your final IP
    - value - IP
    - routing policy - how 53 responds
    - ttl - time record is cached in 53
- $0.50 per month per domain name
- public hosted zone
- private hosted zone
    - to access resources inside a VPC

### API Gateway
- serverless
- websockets capable
- versioning and env (dev, prod) capable
- security - auth, api keys, throttling
- caching
- 29s timeout
- api types
    - http api
        - cheapest
        - proxies
        - no data mapping
        - no api keys or usage plans
        - CORS and OAuth for sec
    - rest api
        - all the features
    - websocket api
        - lambda functions for each life cycle (OnConnect, SendMessage, OnDisconnect)
        - broadcast by hitting api gateway "callback" endpoint from lambda code. sameurl/@connections/connectionId
        - routing - specify "route selection expression" (msg json attr) and define routing map to point to a specific endpoint/function
        - persist connectionIds in DynamoDB
- endpoint types
    - edge optimized
        - default
        - just in one region but all CloudFront edge locations know about it
    - regional
        - for targeting a specific region
        - can manually configure to CloudFront
    - private
        - only accessible from inside your VPC
- security
    - auth - IAM, cognito, custom
    - HTTPS - thru ACM
- integration types
    - MOCK = stubbed endpoints for WIP
    - HTTP_PROXY = just passes req/res
    - AWS_PROXY = lambda
- mapping template
    - translates req/res allowing i.e. json payload going into xml endpoint(s)
    - or formats
- OpenApi compatible (import or export)
    - including validations, but why?
- caching
    - defined at stage level
    - each endpoint can be customized
    - default 300s, up to 3600s
    - expensive
    - Cache-Control: max-age=0
        - plz configure to require IAM permissions
- usage plan
    - customers use api, $$ and configuring how much and who uses API
    - uses api keys to ID customer
- api keys
    - X-Api-Key header needed
    - 1. build, deploy api gateway
    - 2. create usage plan
    - 3. create api key
    - 4. assoc. stages + keys w/ usage plan
- CloudWatch integration
    - at stage level
    - configure logging level (ERROR, INFO, DEBUG, etc.)
    - use x-ray for enhanced logs
    - metrics
        - CacheHitCount, CacheMissCount = cache efficiency checks
        - Count = total endpoint hits
        - IntegrationLatency = measure of fwd to BE service until response from BE service
        - Latency = total in-to-out time
        - 4XXErrors, 5XXErrors = error counts
- throttling
    - 429 status code
    - default 10k/s across all apis
    - can throttle individual endpoints to save entire system
- CORS
    - must enable on API gateway side (do thru console)
    - headers required
        - Access-Control-Allow-Methods
        - Access-Control-Allow-Headers
        - Access-Control-Allow-Origin
- auth
    - IAM policy - sig v4
    - resource policy
        - cross account access
        - for specific IP or endpoint only
    - Cognito User pool
    - Lambda/custom authorizer
        - a (auth spec) lambda handles auth
        - responds with resource policy
        - policy is cached at api gateway level


### DynamoDB
- DynamoDB Accelerator (DAX)
    - only supports write through caching


## aws provided sample Qs - mine then correct
D, B+E, A+E, B+C, A, D, B, D, D, D
D, A+B, A+E, A+D, A, D, B, B, C, D
    .5        1            1  1
### takeaways
appsync, api gateway, cloudwatch

## General learnings
queues vs streams
- both can have lots of messages, need sharding
    - we still partition on a key
- queues are single thread
- queues only send message to 1 consumer
- queues retire message after being sent
- streams have many threads/topics/log file
- streams send messages to all consumers of the topic
- streams persist messages long term as subscribers can get messages from any point in time
caching strategies
- write through - set in cache on write
    - pro: data is always fresh
    - con: some/most data is never read (in some apps/contexts)
    - con: added latency on write because 2 write actions (db + cache) for every req (but usually ok per users)
- lazy loading - write to cache on reads
    - pro: only read data is cached
    - con: added latency on misses (3 actions, miss > db read > cache write)
    - con: data can get stale (writes don't update cache)

### practice tests
## 1 (19 july)
- things to research:
    - review cloud practitioner notes
    ✅ tooling (CodeDeploy, Build)
    ✅ CodeDeploy, appspec listeners/lifecycle hooks
    ✅ cognito
        - IAM - user pools, identity pools
    ✅ Lambda - sqs event source, CloudWatch event source, dep pkg (zip files)
    - below all one udemy section
        - CloudWatch, detailed monitoring, CloudWatch Events, alarms
        - X-Ray
        - EventBridge
    - ecs - launch types (ec2, fargate), vocab task vs pod etc., HOST_PORT:CONTAINER_PORT mappings (0 for host will be automatically handled), task definitions
    - api gateway caching (maybe compile all caching), mapping templates (xml > json)
    - dynamodb - streams, parallel scans, throughput, session feature, operations
    - certificate manager = for issuing SSL/TLS certificates
        - vs kms, secrets mngr, priv cert auth
    - beanstalk - source bundle
    - s3 hive compatible
    - AWS CLI put-metric-data
    - sqs - config (long polling), system arch
    - rds proxy = LB sorta for RDS
    - step functions
- SAML = secure assertion markup language
    - xml auth
- DDL = data def language (subset of SQL, create table etc.)


### feecodecamp youtube (eh)

## elastic beanstalk
- "not for production use" per aws
- built on top of cloud formation
- uses EC2, ELB, ASG, CloudWatch under the hood:
- web env
    - single inst or load balanced service
    - asg, elb
        - asg still used for fail handling
- worker env
    - asg, sqs
- deployment methods
    - all at once
        - ship same code to all instances at the same time
        - takes all old instances out of service during
        - fast but dangerous (if new v is broken)
        - downtime (no availability)
    - rolling
        - only on load balanced (needs ELB)
        - in batches
        - slower but fixes probs of all at once
        - rolling back is complicated (needs another rolling deploy)
        - reduced capacity
    - rolling with addtl batch
        - only on load balanced (needs ELB)
        - completely new full batch then delete old
        - rollbacks still difficult
    - immutable
        - completely new asg
        - wait to destroy old asg
            - easy rollbacks
    - blue/green
        - all considered "in-place" except this one
        - similar to immutable but uses new DNS record
        - DNS mappings need to populate to entire internet :(
        - happens at route 53 level
    - configs in .ebextensions folder
        - files have .config
    - env.yml in root to configure defaults
    - EB has its own CLI
    - can use custom AMIs
    - RDS can be added inside or outside env
        - inside is destroyed on instance destroy (deploy)
    
        
